# miracam

Our world is filled with fake photosâ€”AI-generated or edited. Miracam aims to Make Image Real Again (MIRA). We mint all shots as NFTs with hardware-generated signatures to prove authenticity. Private shots are encrypted and wallet-controlled, preserving privacy on-chain.


## Design

Miracam is a mobile camera app, aimed to capture real, immutable and permanent image. The problem is how do we make sure this image is real? How to we prove that? How do we make sure consumer has seamless experience? How do we make it gasless yet permissionless and trustless at the same time?

Is this solution, we must create native app, so that we can have access to TEE which is Apple Secure Enclave in ios to generate an secp256r1 keypair that no one can has access to except our app. This keypair will be used to sign all the photos generated by our app. 

Then we make account abstraction at "our own way" by generating a keypair, which will be used to sign evm signatures and hold nft and tokens.

These generated data are sent as challenge data and attested by Apple to make sure they are all generated by our app. The attestation report are later being uploaded to ipfs, and then passed to solidity contracts integrated with Chainlink Functions. We need Chainlink Function to pick up the IPFS URL, get the Apple Attestation data from the url and run validation on it. The results are stored onchain which will be used to prove the image later.

Every image together with metadata generated by the app are uploaded to IPFS, the URL is signed by Secure Enclave Keypairs, and then again later verified using P256 verification onchain. The attestation result we have produced earlier are used to prove the signer has been attested, a NFT will be minted as certificate. 

In order to encrypt private image, we generate AES-GCM password, which will then encrypted using Lit Protocol and Sign Protocol, which provide gasless encryption and access control service. 

We are aware that we could just do all this thing alone in mobile client. But we need it be gasless, so the next options is definitely a selfhosted server, with a trusted keypair, However, we want the solution to be trustless to use and permissionless to fork or host. So we cannot limit the access to just certain keypairs.


## Repositories

- [Mobile Client](https://github.com/Miracam/mobile-client): Native mobile client to capture real photo, create Apple Attested Secure Enclave Keypairs (TEE), encrypt content with the help of Lit Protocol and manage access control with Sign Protocol
- [API](https://github.com/Miracam/api): API server, js, hono framework
- [EVM Contracts](https://github.com/Miracam/contracts): Solidity contracts for nft, permit2 token using EIP1271, p256 verifier using EIP7212, and Push Protocos
- [Substreams](https://github.com/Miracam/substreams): Substreams Package auto generated with `substream init`, tracking both nft and Apple Attestation validator contract
- [Chainlink contract](https://github.com/Miracam/chainlink-contract): This contract is a forked from chainlink function hardhat starter kit, modified with purpose to verify Apple secure enclave attestation on chain
- [Substreams Sink](https://github.com/Miracam/substream-sink): Substreams JS Sink run on substreams package, to stream data from blockchain to our database
- [Phala Playground](https://github.com/Miracam/phala): Phala playground, trying to setup a js server to validate Apple Secure Enclave Attestation in decentralized and permissionless way, failed at verifying X509 cert
- [Playground](https://github.com/Miracam/playground): Playground, experiment with lit and sign protocol
